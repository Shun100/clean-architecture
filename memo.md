# ソフトウェアアーキテクチャ

- レイヤードアーキテクチャ

- ヘキサゴナルアーキテクチャ
  - メリット
    - ビジネスロジックが外部の詳細と切り離されているため保守性が高い
    - ポートとアダプターにより外部システムの切り替えが容易
  - デメリット
    - ポートアダプターの概念を理解する必要がある
  - 使いどころ
    - 外部システムや技術的な依存関係が多いアプリケーション

- オニオンアーキテクチャ
  - 特徴
    - ドメインモデルを中心に置き、外側にUIやインフラ層を配置する円構造
    - 全ての依存が外側から内側に向く
  - メリット
    - ビジネスロジックが外側の技術的詳細の影響を受けない
    - ドメイン駆動設計と相性が良い
  - デメリット
    - どの層に何を実装するのかが慣れるまで分かりづらい
    - 小規模プロジェクトでは過剰な設計となる可能性がある

- クリーンアーキテクチャ
  - 特徴
    - ビジネスロジックを中心に置き、外側にUIやインフラ層を配置する円構造
    - 全ての依存が外側から内側に向く
  - メリット
    - ビジネスロジックが外側の技術的詳細の影響を受けない
    - 各層のテストが容易
    - 各層の役割が明確化されてコード整理が容易になる
  - デメリット
    - ディレクトリやファイル数が増えて初期の開発コストが高い
    - 小規模プロジェクトでは過剰な設計となる可能性が高い
  - 使いどころ
    - 長期間にわたって保守や拡張が求められる大規模で複雑なアプリケーション開発

## 注意点

- 全てをアーキテクチャパターンに当てはめようとしないこと


## 題材とするアプリケーション

- 図書館アプリ
  - 書籍管理機能
    - 書籍の登録
      - ID、タイトル、利用可能フラグを持つ書籍が登録できる
    - IDで検索可能
  - ユーザ管理機能
    - ID、メールアドレスを持つユーザを作成できる
  - 書籍貸出管理機能
    - 書籍の貸出
      - 貸出期間は2w
      - 一度に借りられるのは5冊まで
    - 書籍の返却

## 環境構築

``` bash
npm init -y

# ExpressとPrisma Clientのインストール
npm i express @prisma/client

# TypesScriptのインストール
npm i -D typescript @types/node @types/express ts-node-dev prisma

# TypeScriptプロジェクトの初期化
npx tsc --init

```

## セットアップ手順

``` bash
cd app

# package.json（依存関係一覧）の作成
npm init -y

# prisma/schema.prismaの作成（初回のみ）
docker-compose run --rm app npx prisma init

docker compose run --rm app npx prisma migrate dev --name init

docker compose up -d
```

## コマンド

- Prismaのスキーマ定義ファイル(`schema.prisma`)の内容をデータベースに反映する。
  - `npx prisma db push`

## メモ

``` typescript
  // 旧
  import { PrismaClient } from '@prisma/client';

  // 新
  import { PrismaClient } from '../generated/prisma';
```

## レイヤードアーキテクチャ問題点

- 上位層が下位層の実装（具象）に強く依存している
  - 下位層の変更が上位層にまで波及する可能性が高い
- テストの実施が困難
  - テスト用のモックに置き換えることができない

- 問題点に対する解決策
  - インタフェースの活用
    - BookRepositoryやBookServiceのインターフェースを定義
  - 依存性逆転の法則
  - DI
    - 外部から依存関係を注入

## レイヤードアーキテクチャ（疎結合）の問題点

- 小規模なアプリであればこのアーキテクチャで問題ない

- より大規模なアプリになったときの問題
  - 1. Serviceクラスが肥大化する。
    - コードの重複が発生しやすく、品質低下につながる。
  - 2. Bookクラス（Entity）は`@prisma/client`から直接インポートしている。
    - ORMライブラリを変更すると、Bookクラスを利用している箇所を全て修正する必要がある。
  - 3. (疎結合にはなったものの)依然としてビジネスロジック層がデータアクセス層に依存している。
    - アプリケーションのコアとなるビジネスロジック層は何にも依存すべきではない。

## クリーンアーキテクチャ

- 基本構造
  - レイヤードアーキテクチャやヘキサゴナルアーキテクチャなど、それまでに存在したアーキテクチャを整理・統合したもの。
  - 依存関係の方向をコントロールし、ビジネスロジックを外部の変更から守る。
  - 層の数は厳密に決められているわけではなく、プロジェクトの規模に応じて設計者が決めてよい。
    - 一般的には4層構造
      - `Entity`
        - ビジネス上の重要な概念を表す（書籍など） + 永続化のための`Repository`のインタフェース
        - 他の層が`Entity`に依存することはあっても、`Entity`が他の層に依存することは決してない。
        - DDDにも`Entity`という言葉が登場するが、クリーンアーキテクチャのそれとは異なるため注意。
          - クリーンアーキテクチャの`Entity` = DDDの`Domain Model`
      - `Use Cases`
        - ビジネスルールの具体的な適用方法（書籍の登録や検索など）
          - レイヤードアーキテクチャは複数のビジネスルールを1つのクラスで実装していたが、クリーンアーキテクチャではビジネスルールごとにクラスを分割し、クラスの肥大化を防ぐ。
          - `Entity`層にのみ依存する。
      - `Interface Adapters`
        - ビジネスロジックと外部インタフェースを結び付ける。（データ交換や変換）
          - コントローラ、ゲートウェイ（リポジトリ）などが含まれる。
      - `Frameworks and Drivers`
        - Webフレームワーク、ORM、外部APIとの接続など
